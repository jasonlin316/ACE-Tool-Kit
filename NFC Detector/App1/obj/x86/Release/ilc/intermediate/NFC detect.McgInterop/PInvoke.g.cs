#define MCG_WINRT_SUPPORTED
using Mcg.System;
using System;
using System.Collections;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;
using System.Runtime.InteropServices.WindowsRuntime;
using global::Windows.Foundation;
using global::Windows.Foundation.Collections;


// -----------------------------------------------------------------------------------------------------------
// 
// WARNING: THIS SOURCE FILE IS FOR 32-BIT BUILDS ONLY!
// 
// MCG GENERATED CODE
// 
// This C# source file is generated by MCG and is added into the application at compile time to support interop features.
// 
// It has three primary components:
// 
// 1. Public type definitions with interop implementation used by this application including WinRT & COM data structures and P/Invokes.
// 
// 2. The '__Interop' class containing marshaling code that acts as a bridge from managed code to native code.
// 
// 3. The 'McgNative' class containing marshaling code and native type definitions that call into native code and are called by native code.
// 
// -----------------------------------------------------------------------------------------------------------
// 
// warning CS0067: The event 'event' is never used
#pragma warning disable 67
// warning CS0169: The field 'field' is never used
#pragma warning disable 169
// warning CS0649: Field 'field' is never assigned to, and will always have its default value 0
#pragma warning disable 414
// warning CS0414: The private field 'field' is assigned but its value is never used
#pragma warning disable 649
// warning CS1591: Missing XML comment for publicly visible type or member 'Type_or_Member'
#pragma warning disable 1591
// warning CS0108 'member1' hides inherited member 'member2'. Use the new keyword if hiding was intended.
#pragma warning disable 108
// warning CS0114 'member1' hides inherited member 'member2'.  To make the current method override that implementation, add the override keyword. Otherwise add the new keyword.
#pragma warning disable 114
// warning CS0659 'type' overrides Object.Equals but does not override GetHashCode.
#pragma warning disable 659
// warning CS0465 Introducing a 'Finalize' method can interfere with destructor invocation. Did you intend to declare a destructor?
#pragma warning disable 465
// warning CS0028 'function declaration' has the wrong signature to be an entry point
#pragma warning disable 28
// warning CS0162 Unreachable code Detected
#pragma warning disable 162
// warning CS0628 new protected member declared in sealed class
#pragma warning disable 628

namespace __Interop
{
	/// <summary>
	/// P/Invoke class for module '[MRT]'
	/// </summary>
	public unsafe static partial class _MRT_
	{
		// Signature, RhpGetFuncEvalParameterBufferSize, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpGetFuncEvalParameterBufferSize")]
		public static uint RhpGetFuncEvalParameterBufferSize()
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpGetFuncEvalParameterBufferSize();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhpGetFuncEvalMode, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpGetFuncEvalMode")]
		public static uint RhpGetFuncEvalMode()
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpGetFuncEvalMode();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhpRecordDebuggeeInitiatedHandle, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpRecordDebuggeeInitiatedHandle")]
		public static uint RhpRecordDebuggeeInitiatedHandle(void* objectHandle)
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpRecordDebuggeeInitiatedHandle(((void*)objectHandle));
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhpVerifyDebuggerCleanup, [fwd] [return] [EETypeRva:0x00041F6C] void__void, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpVerifyDebuggerCleanup")]
		public static void RhpVerifyDebuggerCleanup()
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhpVerifyDebuggerCleanup();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, RhpGetCurrentThread, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhpGetCurrentThread")]
		public static global::System.IntPtr RhpGetCurrentThread()
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhpGetCurrentThread();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhWaitForPendingFinalizers, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhWaitForPendingFinalizers")]
		public static void RhWaitForPendingFinalizers(int allowReentrantWait)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhWaitForPendingFinalizers(allowReentrantWait);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, _RhYield, [fwd] [return] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "_RhYield")]
		public static int _RhYield()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes._RhYield();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhFlushProcessWriteBuffers, [fwd] [return] [EETypeRva:0x00041F6C] void__void, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhFlushProcessWriteBuffers")]
		public static void RhFlushProcessWriteBuffers()
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhFlushProcessWriteBuffers();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, RhCompatibleReentrantWaitAny, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr___ptr__w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhCompatibleReentrantWaitAny")]
		public static int RhCompatibleReentrantWaitAny(
					int alertable, 
					int timeout, 
					int count, 
					global::System.IntPtr* handles)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop._MRT__PInvokes.RhCompatibleReentrantWaitAny(
								alertable, 
								timeout, 
								count, 
								((global::System.IntPtr*)handles)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, RhCallDescrWorkerNative, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "RhCallDescrWorkerNative")]
		public static void RhCallDescrWorkerNative(global::System.IntPtr callDescr)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.RhCallDescrWorkerNative(callDescr);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, _ecvt_s, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] double__double, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int___ptrint *, [fwd] [in] [EETypeRva:0x000419B0] int___ptrint *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "_ecvt_s")]
		public static void _ecvt_s(
					byte* buffer, 
					int sizeInBytes, 
					double value, 
					int count, 
					int* dec, 
					int* sign)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes._ecvt_s(
								((byte*)buffer), 
								sizeInBytes, 
								value, 
								count, 
								((int*)dec), 
								((int*)sign)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, memmove, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "memmove")]
		public static void memmove(
					byte* dmem, 
					byte* smem, 
					uint size)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.memmove(
								((byte*)dmem), 
								((byte*)smem), 
								size
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}

		// Signature, memset, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "System.Runtime.RuntimeImports", "memset")]
		public static void memset(
					byte* mem, 
					int value, 
					uint size)
		{
			// Marshalling
			// Call to native method
			global::__Interop._MRT__PInvokes.memset(
								((byte*)mem), 
								value, 
								size
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module '*'
	/// </summary>
	public unsafe static partial class _
	{
		// Signature, CallingConventionConverter_GetStubs, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.TypeLoader, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.Runtime.TypeLoader.CallConverterThunk", "CallingConventionConverter_GetStubs")]
		public static void CallingConventionConverter_GetStubs(
					out global::System.IntPtr returnVoidStub, 
					out global::System.IntPtr returnIntegerStub, 
					out global::System.IntPtr commonStub, 
					out global::System.IntPtr returnFloatingPointReturn4Thunk, 
					out global::System.IntPtr returnFloatingPointReturn8Thunk)
		{
			// Marshalling
			fixed (global::System.IntPtr* pinned_returnVoidStub = &(returnVoidStub))
				fixed (global::System.IntPtr* pinned_returnIntegerStub = &(returnIntegerStub))
					fixed (global::System.IntPtr* pinned_commonStub = &(commonStub))
						fixed (global::System.IntPtr* pinned_returnFloatingPointReturn4Thunk = &(returnFloatingPointReturn4Thunk))
							fixed (global::System.IntPtr* pinned_returnFloatingPointReturn8Thunk = &(returnFloatingPointReturn8Thunk))
							{
								// Call to native method
								global::__Interop.__PInvokes.CallingConventionConverter_GetStubs(
													pinned_returnVoidStub, 
													pinned_returnIntegerStub, 
													pinned_commonStub, 
													pinned_returnFloatingPointReturn4Thunk, 
													pinned_returnFloatingPointReturn8Thunk
												);
								global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
							}
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-string-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_string_l1_1_0_dll
	{
		// Signature, WindowsCreateStringReference, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] System_Runtime_InteropServices_HSTRING_HEADER__System_Private_Interop___ptrSystem_Runtime_InteropServices__HSTRING_HEADER__System_Private_Interop *, [fwd] [in] [EETypeRva:0x000419B0] void___ptrvoid *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore", "WindowsCreateStringReference")]
		public static int WindowsCreateStringReference(
					char* sourceString, 
					uint length, 
					global::System_Runtime_InteropServices.HSTRING_HEADER__System_Private_Interop* phstringHeader, 
					void* hstring)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_winrt_string_l1_1_0_dll_PInvokes.WindowsCreateStringReference(
								((ushort*)sourceString), 
								length, 
								((global::System_Runtime_InteropServices.HSTRING_HEADER__System_Private_Interop*)phstringHeader), 
								((void*)hstring)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-errorhandling-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_errorhandling_l1_1_0_dll
	{
		// Signature, GetLastError, [fwd] [return] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "GetLastError")]
		public static int GetLastError()
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes.GetLastError();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, SetLastError, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+mincore", "SetLastError")]
		public static void SetLastError(uint dwErrCode)
		{
			// Marshalling
			// Call to native method
			global::__Interop.api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes.SetLastError(dwErrCode);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_l1_1_0_dll
	{
		// Signature, RoInitialize, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "RoInitialize")]
		public static int RoInitialize(uint initType)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_winrt_l1_1_0_dll_PInvokes.RoInitialize(initType);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-localization-l1-2-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_localization_l1_2_0_dll
	{
		// Signature, IsValidLocaleName, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "IsValidLocaleName")]
		public static int IsValidLocaleName(char* lpLocaleName)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.IsValidLocaleName(((ushort*)lpLocaleName));
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, ResolveLocaleName, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.WinRTInterop.CoreLib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "mincore+mincore_PInvokes", "ResolveLocaleName")]
		public static int ResolveLocaleName(
					char* lpNameToResolve, 
					char* lpLocaleName, 
					int cchLocaleName)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.api_ms_win_core_localization_l1_2_0_dll_PInvokes.ResolveLocaleName(
								((ushort*)lpNameToResolve), 
								((ushort*)lpLocaleName), 
								cchLocaleName
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'kernel32.dll'
	/// </summary>
	public unsafe static partial class kernel32_dll
	{
		// Signature, GetCPInfoExW, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] __Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages___ptr__Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Text.Encoding.CodePages, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetCPInfoExW")]
		public static int GetCPInfoExW(
					uint CodePage, 
					uint dwFlags, 
					global::_.Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages* lpCPInfoEx)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetCPInfoExW(
								CodePage, 
								dwFlags, 
								((global::_.Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages*)lpCPInfoEx)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, GetStdHandle, [fwd] [return] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetStdHandle")]
		public static global::System.IntPtr GetStdHandle(int nStdHandle)
		{
			// Setup
			global::System.IntPtr unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetStdHandle(nStdHandle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, CreateProcess, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process____Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process____Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process, [fwd] [in] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process____Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process____Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "CreateProcess")]
		public static bool CreateProcess(
					string lpApplicationName, 
					global::System.Text.StringBuilder lpCommandLine, 
					ref global::_.Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process procSecAttrs, 
					ref global::_.Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process threadSecAttrs, 
					bool bInheritHandles, 
					int dwCreationFlags, 
					global::System.IntPtr lpEnvironment, 
					string lpCurrentDirectory, 
					ref global::_.Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process lpStartupInfo, 
					ref global::_.Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process lpProcessInformation)
		{
			// Setup
			ushort* unsafe_lpApplicationName = default(ushort*);
			ushort* unsafe_lpCommandLine = default(ushort*);
			ushort* unsafe_lpCurrentDirectory = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				fixed (char* pinned_lpApplicationName = lpApplicationName)
				{
					unsafe_lpApplicationName = (ushort*)pinned_lpApplicationName;
					if (lpCommandLine == null)
						unsafe_lpCommandLine = null;
					else
					{
						unsafe_lpCommandLine = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(lpCommandLine.Capacity * 2 
											+ 2)));
						if (unsafe_lpCommandLine == null)
							throw new global::System.OutOfMemoryException();
					}
					if (unsafe_lpCommandLine != null)
						global::System.Runtime.InteropServices.McgMarshal.StringBuilderToUnicodeString(
											lpCommandLine, 
											unsafe_lpCommandLine
										);
					fixed (global::_.Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process* pinned_procSecAttrs = &(procSecAttrs))
						fixed (global::_.Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process* pinned_threadSecAttrs = &(threadSecAttrs))
							fixed (char* pinned_lpCurrentDirectory = lpCurrentDirectory)
							{
								unsafe_lpCurrentDirectory = (ushort*)pinned_lpCurrentDirectory;
								fixed (global::_.Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process* pinned_lpStartupInfo = &(lpStartupInfo))
									fixed (global::_.Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process* pinned_lpProcessInformation = &(lpProcessInformation))
									{
										global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
										// Call to native method
										unsafe___value = global::__Interop.kernel32_dll_PInvokes.CreateProcess(
															unsafe_lpApplicationName, 
															unsafe_lpCommandLine, 
															pinned_procSecAttrs, 
															pinned_threadSecAttrs, 
															(bInheritHandles ? 1 : 0), 
															dwCreationFlags, 
															lpEnvironment, 
															unsafe_lpCurrentDirectory, 
															pinned_lpStartupInfo, 
															pinned_lpProcessInformation
														);
										global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
										global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
									}
							}
					if (lpCommandLine != null)
						global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
											unsafe_lpCommandLine, 
											lpCommandLine
										);
				}
				// Return
				return unsafe___value != 0;
			}
			finally
			{
				// Cleanup
				if (unsafe_lpCommandLine != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_lpCommandLine);
			}
		}

		// Signature, GetConsoleCP, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetConsoleCP")]
		public static uint GetConsoleCP()
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetConsoleCP();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, GetConsoleOutputCP, [fwd] [return] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetConsoleOutputCP")]
		public static uint GetConsoleOutputCP()
		{
			// Setup
			uint unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetConsoleOutputCP();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value;
		}

		// Signature, CloseHandle, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "CloseHandle")]
		public static bool CloseHandle(global::System.IntPtr handle)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.CloseHandle(handle);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			// Return
			return unsafe___value != 0;
		}

		// Signature, GetCurrentProcess, [fwd] [return] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeProcessHandle__System_Diagnostics_Process____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetCurrentProcess")]
		public static global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process GetCurrentProcess()
		{
			// Setup
			global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetCurrentProcess();
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, DuplicateHandle, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeProcessHandle__System_Diagnostics_Process____w64 int, [fwd] [in] [EETypeRva:0x000434A4] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeProcessHandle__System_Diagnostics_Process____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeFileHandle__System_Private_CoreLib____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "DuplicateHandle")]
		public static bool DuplicateHandle(
					global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process hSourceProcessHandle, 
					global::System.Runtime.InteropServices.SafeHandle hSourceHandle, 
					global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process hTargetProcess, 
					out global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_Private_CoreLib targetHandle, 
					int dwDesiredAccess, 
					bool bInheritHandle, 
					int dwOptions)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			bool addRefed_2 = false;
			global::System.IntPtr unsafe_targetHandle;
			int unsafe___value;
			// Marshalling
			hSourceProcessHandle.DangerousAddRef(ref addRefed);
			hSourceHandle.DangerousAddRef(ref addRefed_1);
			hTargetProcess.DangerousAddRef(ref addRefed_2);
			targetHandle = new global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_Private_CoreLib();
			unsafe_targetHandle = targetHandle.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.DuplicateHandle(
								hSourceProcessHandle.DangerousGetHandle(), 
								hSourceHandle.DangerousGetHandle(), 
								hTargetProcess.DangerousGetHandle(), 
								&(unsafe_targetHandle), 
								dwDesiredAccess, 
								(bInheritHandle ? 1 : 0), 
								dwOptions
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								targetHandle, 
								unsafe_targetHandle
							);
			if (addRefed_2)
				hTargetProcess.DangerousRelease();
			if (addRefed_1)
				hSourceHandle.DangerousRelease();
			if (addRefed)
				hSourceProcessHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, GetProcessId, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeProcessHandle__System_Diagnostics_Process____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetProcessId")]
		public static int GetProcessId(global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process nativeHandle)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			nativeHandle.DangerousAddRef(ref addRefed);
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetProcessId(nativeHandle.DangerousGetHandle());
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			if (addRefed)
				nativeHandle.DangerousRelease();
			// Return
			return unsafe___value;
		}

		// Signature, GetExitCodeProcess, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeProcessHandle__System_Diagnostics_Process____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetExitCodeProcess")]
		public static bool GetExitCodeProcess(
					global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process processHandle, 
					out int exitCode)
		{
			// Setup
			bool addRefed = false;
			int unsafe___value;
			// Marshalling
			processHandle.DangerousAddRef(ref addRefed);
			fixed (int* pinned_exitCode = &(exitCode))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetExitCodeProcess(
									processHandle.DangerousGetHandle(), 
									pinned_exitCode
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			if (addRefed)
				processHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, CreatePipe, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeFileHandle__System_Private_CoreLib____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeFileHandle__System_Private_CoreLib____w64 int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process____Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "CreatePipe")]
		public static bool CreatePipe(
					out global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_Private_CoreLib hReadPipe, 
					out global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_Private_CoreLib hWritePipe, 
					ref global::_.Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process lpPipeAttributes, 
					int nSize)
		{
			// Setup
			global::System.IntPtr unsafe_hReadPipe;
			global::System.IntPtr unsafe_hWritePipe;
			int unsafe___value;
			// Marshalling
			hReadPipe = new global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_Private_CoreLib();
			unsafe_hReadPipe = hReadPipe.DangerousGetHandle();
			hWritePipe = new global::Microsoft.Win32.SafeHandles.SafeFileHandle__System_Private_CoreLib();
			unsafe_hWritePipe = hWritePipe.DangerousGetHandle();
			fixed (global::_.Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process* pinned_lpPipeAttributes = &(lpPipeAttributes))
			{
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.CreatePipe(
									&(unsafe_hReadPipe), 
									&(unsafe_hWritePipe), 
									pinned_lpPipeAttributes, 
									nSize
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								hWritePipe, 
								unsafe_hWritePipe
							);
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								hReadPipe, 
								unsafe_hReadPipe
							);
			// Return
			return unsafe___value != 0;
		}

		// Signature, DuplicateHandle__0, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeProcessHandle__System_Diagnostics_Process____w64 int, [fwd] [in] [EETypeRva:0x000434A4] System_Runtime_InteropServices_SafeHandle____w64 int, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeProcessHandle__System_Diagnostics_Process____w64 int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeWaitHandle__System_Private_CoreLib____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "DuplicateHandle")]
		public static bool DuplicateHandle__0(
					global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process hSourceProcessHandle, 
					global::System.Runtime.InteropServices.SafeHandle hSourceHandle, 
					global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process hTargetProcess, 
					out global::Microsoft.Win32.SafeHandles.SafeWaitHandle__System_Private_CoreLib targetHandle, 
					int dwDesiredAccess, 
					bool bInheritHandle, 
					int dwOptions)
		{
			// Setup
			bool addRefed = false;
			bool addRefed_1 = false;
			bool addRefed_2 = false;
			global::System.IntPtr unsafe_targetHandle;
			int unsafe___value;
			// Marshalling
			hSourceProcessHandle.DangerousAddRef(ref addRefed);
			hSourceHandle.DangerousAddRef(ref addRefed_1);
			hTargetProcess.DangerousAddRef(ref addRefed_2);
			targetHandle = new global::Microsoft.Win32.SafeHandles.SafeWaitHandle__System_Private_CoreLib();
			unsafe_targetHandle = targetHandle.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.DuplicateHandle__0(
								hSourceProcessHandle.DangerousGetHandle(), 
								hSourceHandle.DangerousGetHandle(), 
								hTargetProcess.DangerousGetHandle(), 
								&(unsafe_targetHandle), 
								dwDesiredAccess, 
								(bInheritHandle ? 1 : 0), 
								dwOptions
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								targetHandle, 
								unsafe_targetHandle
							);
			if (addRefed_2)
				hTargetProcess.DangerousRelease();
			if (addRefed_1)
				hSourceHandle.DangerousRelease();
			if (addRefed)
				hSourceProcessHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, GetComputerName, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000418E8] char__wchar_t, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] uint__unsigned int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetComputerName")]
		public static int GetComputerName(
					ref char lpBuffer, 
					ref uint nSize)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (char* pinned_lpBuffer = &(lpBuffer))
			{
				ushort* unsafe_pinned_lpBuffer = (ushort*)pinned_lpBuffer;
				fixed (uint* pinned_nSize = &(nSize))
				{
					// Call to native method
					unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetComputerName(
										unsafe_pinned_lpBuffer, 
										pinned_nSize
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				}
			}
			// Return
			return unsafe___value;
		}

		// Signature, OpenProcess, [fwd] [return] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeProcessHandle__System_Diagnostics_Process____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "OpenProcess")]
		public static global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process OpenProcess(
					int access, 
					bool inherit, 
					int processId)
		{
			// Setup
			global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process __value;
			global::System.IntPtr unsafe___value;
			// Marshalling
			__value = new global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.OpenProcess(
								access, 
								(inherit ? 1 : 0), 
								processId
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								__value, 
								unsafe___value
							);
			// Return
			return __value;
		}

		// Signature, WideCharToMultiByte, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "WideCharToMultiByte")]
		public static int WideCharToMultiByte(
					uint CodePage, 
					uint dwFlags, 
					char* lpWideCharStr, 
					int cchWideChar, 
					byte* lpMultiByteStr, 
					int cbMultiByte, 
					global::System.IntPtr lpDefaultChar, 
					global::System.IntPtr lpUsedDefaultChar)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.WideCharToMultiByte(
								CodePage, 
								dwFlags, 
								((ushort*)lpWideCharStr), 
								cchWideChar, 
								((byte*)lpMultiByteStr), 
								cbMultiByte, 
								lpDefaultChar, 
								lpUsedDefaultChar
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, MultiByteToWideChar, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "MultiByteToWideChar")]
		public static int MultiByteToWideChar(
					uint CodePage, 
					uint dwFlags, 
					byte* lpMultiByteStr, 
					int cbMultiByte, 
					char* lpWideCharStr, 
					int cchWideChar)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.MultiByteToWideChar(
								CodePage, 
								dwFlags, 
								((byte*)lpMultiByteStr), 
								cbMultiByte, 
								((ushort*)lpWideCharStr), 
								cchWideChar
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, FormatMessage, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] char___ptrwchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x00042A40] rg_System_IntPtr____w64 int *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("Microsoft.Win32.Primitives, Version=4.1.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "FormatMessage")]
		public static int FormatMessage(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					char* lpBuffer, 
					int nSize, 
					global::System.IntPtr[] arguments)
		{
			// Setup
			global::System.IntPtr* unsafe_arguments;
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_arguments = ((arguments != null 
						&& arguments.Length == 0) ? new global::System.IntPtr[1] : arguments))
			{
				unsafe_arguments = (global::System.IntPtr*)pinned_arguments;
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.kernel32_dll_PInvokes.FormatMessage(
									dwFlags, 
									lpSource, 
									dwMessageId, 
									dwLanguageId, 
									((ushort*)lpBuffer), 
									nSize, 
									unsafe_arguments
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			}
			// Return
			return unsafe___value;
		}

		// Signature, GetCPInfoExW__0, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] uint__unsigned int, [fwd] [in] [EETypeRva:0x000419B0] __Interop_Kernel32_CPINFOEXW__System_Diagnostics_Process___ptr__Interop_Kernel32_CPINFOEXW__System_Diagnostics_Process *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "GetCPInfoExW")]
		public static int GetCPInfoExW__0(
					uint CodePage, 
					uint dwFlags, 
					global::_.Interop_Kernel32_CPINFOEXW__System_Diagnostics_Process* lpCPInfoEx)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			// Call to native method
			unsafe___value = global::__Interop.kernel32_dll_PInvokes.GetCPInfoExW__0(
								CodePage, 
								dwFlags, 
								((global::_.Interop_Kernel32_CPINFOEXW__System_Diagnostics_Process*)lpCPInfoEx)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
			return unsafe___value;
		}

		// Signature, EnumProcesses, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00042A40] rg_int__int *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] int__int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Kernel32", "EnumProcesses")]
		public static bool EnumProcesses(
					int[] processIds, 
					int size, 
					out int needed)
		{
			// Setup
			int* unsafe_processIds;
			int unsafe___value;
			// Marshalling
			fixed (int* pinned_processIds = ((processIds != null 
						&& processIds.Length == 0) ? new int[1] : processIds))
			{
				unsafe_processIds = (int*)pinned_processIds;
				fixed (int* pinned_needed = &(needed))
				{
					global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
					// Call to native method
					unsafe___value = global::__Interop.kernel32_dll_PInvokes.EnumProcesses(
										unsafe_processIds, 
										size, 
										pinned_needed
									);
					global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
					global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				}
			}
			// Return
			return unsafe___value != 0;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'advapi32.dll'
	/// </summary>
	public unsafe static partial class advapi32_dll
	{
		// Signature, CreateProcessWithLogonW, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00042D60] __Interop_Advapi32_LogonFlags__System_Diagnostics_Process__Interop_Advapi32_LogonFlags__System_Diagnostics_Process, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [out] [EETypeRva:0x00041CF4] System_Text_StringBuilder__wchar_t *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process____Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process, [fwd] [in] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process____Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "CreateProcessWithLogonW")]
		public static bool CreateProcessWithLogonW(
					string userName, 
					string domain, 
					global::System.IntPtr password, 
					global::_.Interop_Advapi32_LogonFlags__System_Diagnostics_Process logonFlags, 
					string appName, 
					global::System.Text.StringBuilder cmdLine, 
					int creationFlags, 
					global::System.IntPtr environmentBlock, 
					string lpCurrentDirectory, 
					ref global::_.Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process lpStartupInfo, 
					ref global::_.Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process lpProcessInformation)
		{
			// Setup
			ushort* unsafe_userName = default(ushort*);
			ushort* unsafe_domain = default(ushort*);
			ushort* unsafe_appName = default(ushort*);
			ushort* unsafe_cmdLine = default(ushort*);
			ushort* unsafe_lpCurrentDirectory = default(ushort*);
			int unsafe___value;
			try
			{
				// Marshalling
				fixed (char* pinned_userName = userName)
				{
					unsafe_userName = (ushort*)pinned_userName;
					fixed (char* pinned_domain = domain)
					{
						unsafe_domain = (ushort*)pinned_domain;
						fixed (char* pinned_appName = appName)
						{
							unsafe_appName = (ushort*)pinned_appName;
							if (cmdLine == null)
								unsafe_cmdLine = null;
							else
							{
								unsafe_cmdLine = (ushort*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(checked(cmdLine.Capacity * 2 
													+ 2)));
								if (unsafe_cmdLine == null)
									throw new global::System.OutOfMemoryException();
							}
							if (unsafe_cmdLine != null)
								global::System.Runtime.InteropServices.McgMarshal.StringBuilderToUnicodeString(
													cmdLine, 
													unsafe_cmdLine
												);
							fixed (char* pinned_lpCurrentDirectory = lpCurrentDirectory)
							{
								unsafe_lpCurrentDirectory = (ushort*)pinned_lpCurrentDirectory;
								fixed (global::_.Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process* pinned_lpStartupInfo = &(lpStartupInfo))
									fixed (global::_.Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process* pinned_lpProcessInformation = &(lpProcessInformation))
									{
										global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
										// Call to native method
										unsafe___value = global::__Interop.advapi32_dll_PInvokes.CreateProcessWithLogonW(
															unsafe_userName, 
															unsafe_domain, 
															password, 
															logonFlags, 
															unsafe_appName, 
															unsafe_cmdLine, 
															creationFlags, 
															environmentBlock, 
															unsafe_lpCurrentDirectory, 
															pinned_lpStartupInfo, 
															pinned_lpProcessInformation
														);
										global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
										global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
									}
							}
							if (cmdLine != null)
								global::System.Runtime.InteropServices.McgMarshal.UnicodeStringToStringBuilder(
													unsafe_cmdLine, 
													cmdLine
												);
						}
					}
				}
				// Return
				return unsafe___value != 0;
			}
			finally
			{
				// Cleanup
				if (unsafe_cmdLine != null)
					global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_cmdLine);
			}
		}

		// Signature, LookupPrivilegeValue, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [in] [EETypeRva:0x00041B44] string__wchar_t *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x0004314C] __Interop_Advapi32_LUID__System_Diagnostics_Process____Interop_Advapi32_LUID__System_Diagnostics_Process, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "LookupPrivilegeValue")]
		public static bool LookupPrivilegeValue(
					string lpSystemName, 
					string lpName, 
					out global::_.Interop_Advapi32_LUID__System_Diagnostics_Process lpLuid)
		{
			// Setup
			ushort* unsafe_lpSystemName = default(ushort*);
			ushort* unsafe_lpName = default(ushort*);
			int unsafe___value;
			// Marshalling
			fixed (char* pinned_lpSystemName = lpSystemName)
			{
				unsafe_lpSystemName = (ushort*)pinned_lpSystemName;
				fixed (char* pinned_lpName = lpName)
				{
					unsafe_lpName = (ushort*)pinned_lpName;
					fixed (global::_.Interop_Advapi32_LUID__System_Diagnostics_Process* pinned_lpLuid = &(lpLuid))
					{
						global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
						// Call to native method
						unsafe___value = global::__Interop.advapi32_dll_PInvokes.LookupPrivilegeValue(
											unsafe_lpSystemName, 
											unsafe_lpName, 
											pinned_lpLuid
										);
						global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
						global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
					}
				}
			}
			// Return
			return unsafe___value != 0;
		}

		// Signature, OpenProcessToken, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeProcessHandle__System_Diagnostics_Process____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeTokenHandle__System_Diagnostics_Process____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "OpenProcessToken")]
		public static bool OpenProcessToken(
					global::Microsoft.Win32.SafeHandles.SafeProcessHandle__System_Diagnostics_Process ProcessHandle, 
					int DesiredAccess, 
					out global::Microsoft.Win32.SafeHandles.SafeTokenHandle__System_Diagnostics_Process TokenHandle)
		{
			// Setup
			bool addRefed = false;
			global::System.IntPtr unsafe_TokenHandle;
			int unsafe___value;
			// Marshalling
			ProcessHandle.DangerousAddRef(ref addRefed);
			TokenHandle = new global::Microsoft.Win32.SafeHandles.SafeTokenHandle__System_Diagnostics_Process();
			unsafe_TokenHandle = TokenHandle.DangerousGetHandle();
			global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
			// Call to native method
			unsafe___value = global::__Interop.advapi32_dll_PInvokes.OpenProcessToken(
								ProcessHandle.DangerousGetHandle(), 
								DesiredAccess, 
								&(unsafe_TokenHandle)
							);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
			global::System.Runtime.InteropServices.McgMarshal.InitializeHandle(
								TokenHandle, 
								unsafe_TokenHandle
							);
			if (addRefed)
				ProcessHandle.DangerousRelease();
			// Return
			return unsafe___value != 0;
		}

		// Signature, AdjustTokenPrivileges, [fwd] [return] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x000434A4] Microsoft_Win32_SafeHandles_SafeTokenHandle__System_Diagnostics_Process____w64 int, [fwd] [in] [EETypeRva:0x00040848] bool__System.Boolean, [fwd] [in] [EETypeRva:0x00043084] __Interop_Advapi32_TokenPrivileges__System_Diagnostics_Process____Interop_Advapi32_TokenPrivileges__System_Diagnostics_Process *, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Diagnostics.Process, Version=4.2.1.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Interop+Advapi32", "AdjustTokenPrivileges")]
		public static bool AdjustTokenPrivileges(
					global::Microsoft.Win32.SafeHandles.SafeTokenHandle__System_Diagnostics_Process TokenHandle, 
					bool DisableAllPrivileges, 
					global::_.Interop_Advapi32_TokenPrivileges__System_Diagnostics_Process NewState, 
					int BufferLength, 
					global::System.IntPtr PreviousState, 
					global::System.IntPtr ReturnLength)
		{
			// Setup
			bool addRefed = false;
			global::_.Interop_Advapi32_TokenPrivileges__System_Diagnostics_Process__Impl.UnsafeType* unsafe_NewState = default(global::_.Interop_Advapi32_TokenPrivileges__System_Diagnostics_Process__Impl.UnsafeType*);
			int unsafe___value;
			try
			{
				// Marshalling
				TokenHandle.DangerousAddRef(ref addRefed);
				unsafe_NewState = (global::_.Interop_Advapi32_TokenPrivileges__System_Diagnostics_Process__Impl.UnsafeType*)global::System.Runtime.InteropServices.McgMarshal.CoTaskMemAllocAndZeroMemory(new global::System.IntPtr(sizeof(global::_.Interop_Advapi32_TokenPrivileges__System_Diagnostics_Process__Impl.UnsafeType)));
				global::_.Interop_Advapi32_TokenPrivileges__System_Diagnostics_Process__Impl.Marshal__SafeToUnsafe(
									NewState, 
									out (*(unsafe_NewState))
								);
				global::System.Runtime.InteropServices.McgMarshal.ClearLastWin32Error();
				// Call to native method
				unsafe___value = global::__Interop.advapi32_dll_PInvokes.AdjustTokenPrivileges(
									TokenHandle.DangerousGetHandle(), 
									(DisableAllPrivileges ? 1 : 0), 
									unsafe_NewState, 
									BufferLength, 
									PreviousState, 
									ReturnLength
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				global::System.Runtime.InteropServices.McgMarshal.SaveLastWin32Error();
				if (addRefed)
					TokenHandle.DangerousRelease();
				// Return
				return unsafe___value != 0;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.McgMarshal.SafeCoTaskMemFree(unsafe_NewState);
			}
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-com-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_com_l1_1_0_dll
	{
		// Signature, CoCreateInstance, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, [fwd] [in] [EETypeRva:0x000419B0] int__int, [fwd] [in] [EETypeRva:0x000419B0] byte___ptrunsigned char *, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.StackTraceGenerator, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.StackTraceGenerator.StackTraceGenerator", "CoCreateInstance")]
		public static int CoCreateInstance(
					byte* rclsid, 
					global::System.IntPtr pUnkOuter, 
					int dwClsContext, 
					byte* riid, 
					out global::System.IntPtr ppv)
		{
			// Setup
			int unsafe___value;
			// Marshalling
			fixed (global::System.IntPtr* pinned_ppv = &(ppv))
			{
				// Call to native method
				unsafe___value = global::__Interop.api_ms_win_core_com_l1_1_0_dll_PInvokes.CoCreateInstance(
									((byte*)rclsid), 
									pUnkOuter, 
									dwClsContext, 
									((byte*)riid), 
									pinned_ppv
								);
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			}
			// Return
			return unsafe___value;
		}
	}

	/// <summary>
	/// P/Invoke class for module 'OleAut32'
	/// </summary>
	public unsafe static partial class OleAut32
	{
		// Signature, SysFreeString, [fwd] [return] [EETypeRva:0x00041F6C] void__void, [fwd] [in] [EETypeRva:0x000419B0] System_IntPtr____w64 int, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Private.StackTraceGenerator, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b03f5f7f11d50a3a", "Internal.LightweightInterop.MarshalExtensions", "SysFreeString")]
		public static void SysFreeString(global::System.IntPtr bstr)
		{
			// Marshalling
			// Call to native method
			global::__Interop.OleAut32_PInvokes.SysFreeString(bstr);
			global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
			// Return
		}
	}

	/// <summary>
	/// P/Invoke class for module 'api-ms-win-core-winrt-robuffer-l1-1-0.dll'
	/// </summary>
	public unsafe static partial class api_ms_win_core_winrt_robuffer_l1_1_0_dll
	{
		// Signature, RoGetBufferMarshaler, [fwd] [return] [EETypeRva:0x000419B0] int__int, [fwd] [out] [managedbyref] [nativebyref] [EETypeRva:0x00043660] System_Runtime_InteropServices_IMarshal__System_Runtime_WindowsRuntime__System_Runtime_InteropServices__IMarshal__System_Runtime_WindowsRuntime *, 
		[global::System.Runtime.InteropServices.McgPInvokeMarshalStub("System.Runtime.WindowsRuntime, Version=4.0.14.0, Culture=neutral, PublicKeyToken=b77a5c561934e089", "Interop+mincore", "RoGetBufferMarshaler")]
		public static int RoGetBufferMarshaler(out global::System_Runtime_InteropServices.IMarshal__System_Runtime_WindowsRuntime bufferMarshalerPtr)
		{
			// Setup
			void* unsafe_bufferMarshalerPtr = default(void*);
			int unsafe___value;
			try
			{
				// Marshalling
				unsafe_bufferMarshalerPtr = null;
				// Call to native method
				unsafe___value = global::__Interop.api_ms_win_core_winrt_robuffer_l1_1_0_dll_PInvokes.RoGetBufferMarshaler(&(unsafe_bufferMarshalerPtr));
				global::System.Diagnostics.DebugAnnotations.PreviousCallContainsDebuggerStepInCode();
				bufferMarshalerPtr = (global::System_Runtime_InteropServices.IMarshal__System_Runtime_WindowsRuntime)global::System.Runtime.InteropServices.McgMarshal.ComInterfaceToObject(
									((global::System.IntPtr)unsafe_bufferMarshalerPtr), 
									global::System.Runtime.InteropServices.TypeOfHelper.RuntimeTypeHandleOf("System.Runtime.InteropServices.IMarshal,System.Runtime.WindowsRuntime, Version=4.0.14.0, Culture=neutral, Public" +
											"KeyToken=b77a5c561934e089")
								);
				// Return
				return unsafe___value;
			}
			finally
			{
				// Cleanup
				global::System.Runtime.InteropServices.McgMarshal.ComSafeRelease(new global::System.IntPtr(((void*)unsafe_bufferMarshalerPtr)));
			}
		}
	}

	public unsafe static partial class _MRT__PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static uint RhpGetFuncEvalParameterBufferSize();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static uint RhpGetFuncEvalMode();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static uint RhpRecordDebuggeeInitiatedHandle(void* objectHandle);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static void RhpVerifyDebuggerCleanup();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static global::System.IntPtr RhpGetCurrentThread();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void RhWaitForPendingFinalizers(int allowReentrantWait);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", EntryPoint="RhYield", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static int _RhYield();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Cdecl)]
		public extern static void RhFlushProcessWriteBuffers();

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int RhCompatibleReentrantWaitAny(
					int alertable, 
					int timeout, 
					int count, 
					global::System.IntPtr* handles);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", EntryPoint="RhCallDescrWorker", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void RhCallDescrWorkerNative(global::System.IntPtr callDescr);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void _ecvt_s(
					byte* buffer, 
					int sizeInBytes, 
					double value, 
					int count, 
					int* dec, 
					int* sign);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void memmove(
					byte* dmem, 
					byte* smem, 
					uint size);

		[global::System.Runtime.InteropServices.DllImport("[MRT]", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void memset(
					byte* mem, 
					int value, 
					uint size);
	}

	public unsafe static partial class __PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("*", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void CallingConventionConverter_GetStubs(
					global::System.IntPtr* returnVoidStub, 
					global::System.IntPtr* returnIntegerStub, 
					global::System.IntPtr* commonStub, 
					global::System.IntPtr* returnFloatingPointReturn4Thunk, 
					global::System.IntPtr* returnFloatingPointReturn8Thunk);
	}

	public unsafe static partial class api_ms_win_core_winrt_string_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-string-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WindowsCreateStringReference(
					ushort* sourceString, 
					uint length, 
					global::System_Runtime_InteropServices.HSTRING_HEADER__System_Private_Interop* phstringHeader, 
					void* hstring);
	}

	public unsafe static partial class api_ms_win_core_errorhandling_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-errorhandling-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetLastError();

		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-errorhandling-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void SetLastError(uint dwErrCode);
	}

	public unsafe static partial class api_ms_win_core_winrt_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int RoInitialize(uint initType);
	}

	public unsafe static partial class api_ms_win_core_localization_l1_2_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int IsValidLocaleName(ushort* lpLocaleName);

		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-localization-l1-2-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int ResolveLocaleName(
					ushort* lpNameToResolve, 
					ushort* lpLocaleName, 
					int cchLocaleName);
	}

	public unsafe static partial class kernel32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetCPInfoExW(
					uint CodePage, 
					uint dwFlags, 
					global::_.Interop_Kernel32_CPINFOEXW__System_Text_Encoding_CodePages* lpCPInfoEx);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr GetStdHandle(int nStdHandle);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="CreateProcessW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CreateProcess(
					ushort* lpApplicationName, 
					ushort* lpCommandLine, 
					global::_.Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process* procSecAttrs, 
					global::_.Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process* threadSecAttrs, 
					int bInheritHandles, 
					int dwCreationFlags, 
					global::System.IntPtr lpEnvironment, 
					ushort* lpCurrentDirectory, 
					global::_.Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process* lpStartupInfo, 
					global::_.Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process* lpProcessInformation);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint GetConsoleCP();

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static uint GetConsoleOutputCP();

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CloseHandle(global::System.IntPtr handle);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr GetCurrentProcess();

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int DuplicateHandle(
					global::System.IntPtr hSourceProcessHandle, 
					global::System.IntPtr hSourceHandle, 
					global::System.IntPtr hTargetProcess, 
					global::System.IntPtr* targetHandle, 
					int dwDesiredAccess, 
					int bInheritHandle, 
					int dwOptions);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetProcessId(global::System.IntPtr nativeHandle);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetExitCodeProcess(
					global::System.IntPtr processHandle, 
					int* exitCode);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CreatePipe(
					global::System.IntPtr* hReadPipe, 
					global::System.IntPtr* hWritePipe, 
					global::_.Interop_Kernel32_SECURITY_ATTRIBUTES__System_Diagnostics_Process* lpPipeAttributes, 
					int nSize);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="DuplicateHandle", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int DuplicateHandle__0(
					global::System.IntPtr hSourceProcessHandle, 
					global::System.IntPtr hSourceHandle, 
					global::System.IntPtr hTargetProcess, 
					global::System.IntPtr* targetHandle, 
					int dwDesiredAccess, 
					int bInheritHandle, 
					int dwOptions);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="GetComputerNameW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetComputerName(
					ushort* lpBuffer, 
					uint* nSize);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static global::System.IntPtr OpenProcess(
					int access, 
					int inherit, 
					int processId);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int WideCharToMultiByte(
					uint CodePage, 
					uint dwFlags, 
					ushort* lpWideCharStr, 
					int cchWideChar, 
					byte* lpMultiByteStr, 
					int cbMultiByte, 
					global::System.IntPtr lpDefaultChar, 
					global::System.IntPtr lpUsedDefaultChar);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int MultiByteToWideChar(
					uint CodePage, 
					uint dwFlags, 
					byte* lpMultiByteStr, 
					int cbMultiByte, 
					ushort* lpWideCharStr, 
					int cchWideChar);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="FormatMessageW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int FormatMessage(
					int dwFlags, 
					global::System.IntPtr lpSource, 
					uint dwMessageId, 
					int dwLanguageId, 
					ushort* lpBuffer, 
					int nSize, 
					global::System.IntPtr* arguments);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="GetCPInfoExW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int GetCPInfoExW__0(
					uint CodePage, 
					uint dwFlags, 
					global::_.Interop_Kernel32_CPINFOEXW__System_Diagnostics_Process* lpCPInfoEx);

		[global::System.Runtime.InteropServices.DllImport("kernel32.dll", EntryPoint="K32EnumProcesses", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int EnumProcesses(
					int* processIds, 
					int size, 
					int* needed);
	}

	public unsafe static partial class advapi32_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CreateProcessWithLogonW(
					ushort* userName, 
					ushort* domain, 
					global::System.IntPtr password, 
					global::_.Interop_Advapi32_LogonFlags__System_Diagnostics_Process logonFlags, 
					ushort* appName, 
					ushort* cmdLine, 
					int creationFlags, 
					global::System.IntPtr environmentBlock, 
					ushort* lpCurrentDirectory, 
					global::_.Interop_Kernel32_STARTUPINFO__System_Diagnostics_Process* lpStartupInfo, 
					global::_.Interop_Kernel32_PROCESS_INFORMATION__System_Diagnostics_Process* lpProcessInformation);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", EntryPoint="LookupPrivilegeValueW", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int LookupPrivilegeValue(
					ushort* lpSystemName, 
					ushort* lpName, 
					global::_.Interop_Advapi32_LUID__System_Diagnostics_Process* lpLuid);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int OpenProcessToken(
					global::System.IntPtr ProcessHandle, 
					int DesiredAccess, 
					global::System.IntPtr* TokenHandle);

		[global::System.Runtime.InteropServices.DllImport("advapi32.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int AdjustTokenPrivileges(
					global::System.IntPtr TokenHandle, 
					int DisableAllPrivileges, 
					global::_.Interop_Advapi32_TokenPrivileges__System_Diagnostics_Process__Impl.UnsafeType* NewState, 
					int BufferLength, 
					global::System.IntPtr PreviousState, 
					global::System.IntPtr ReturnLength);
	}

	public unsafe static partial class api_ms_win_core_com_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-com-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static int CoCreateInstance(
					byte* rclsid, 
					global::System.IntPtr pUnkOuter, 
					int dwClsContext, 
					byte* riid, 
					global::System.IntPtr* ppv);
	}

	public unsafe static partial class OleAut32_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("OleAut32", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.Winapi)]
		public extern static void SysFreeString(global::System.IntPtr bstr);
	}

	public unsafe static partial class api_ms_win_core_winrt_robuffer_l1_1_0_dll_PInvokes
	{
		[global::System.Runtime.InteropServices.DllImport("api-ms-win-core-winrt-robuffer-l1-1-0.dll", CallingConvention=global::System.Runtime.InteropServices.CallingConvention.StdCall)]
		public extern static int RoGetBufferMarshaler(void** bufferMarshalerPtr);
	}
}

